name: Windows

on:
  workflow_call:
    inputs:
      profile:
        required: false
        default: "release"
        type: string
      unit-tests:
        required: false
        default: false
        type: boolean
      upload:
        required: false
        default: false
        type: boolean
      github-release-id:
        required: false
        type: string
  workflow_dispatch:
    inputs:
      profile:
        required: false
        default: "release"
        options: ["release", "debug", "production"]
        type: choice
      unit-tests:
        required: false
        default: false
        type: boolean
      upload:
        required: false
        default: false
        type: boolean
      github-release-id:
        required: false
        type: string

env:
  RUST_BACKTRACE: 1
  SHELL: /bin/bash
  CCACHE: "ccache"
  CARGO_TARGET_DIR: C:\\a\\servo\\servo\\target
  # clang_sys will search msys path before Program Files\LLVM
  # so we need to override this behaviour until we update clang-sys
  # https://github.com/KyleMayes/clang-sys/issues/150
  LIBCLANG_PATH: C:\\Program Files\\LLVM\\bin
  RUSTUP_WINDOWS_PATH_ADD_BIN: 1

jobs:
  runner-select:
    name: Runner select
    runs-on: ubuntu-latest
    outputs:
      unique-id: ${{ steps.select.outputs.id }}
      runner-label: ${{ steps.select.outputs.label }}
    concurrency:
      group: servo-reserve-self-hosted-runner
      cancel-in-progress: false
    permissions: write-all
    steps:
      - name: Select and reserve best available runner
        id: select
        run: |
          set -x

          github_hosted_runner_label=windows-2022
          self_hosted_runner_label=self-hosted-windows10
          self_hosted_runner_scope=/repos/${{ github.repository }}/actions/runners
          export GH_TOKEN=${{ secrets.RUNNER_API_TOKEN }}

          runners=$(mktemp)
          gh api "$self_hosted_runner_scope" > $runners

          # Generate a unique id that allows the workload job to find the runner
          # we are reserving for it (via runner labels), and allows the timeout
          # job to find the workload job run (via the job’s friendly name), even
          # if there are multiple instances in the workflow call tree.
          random32=$(LC_ALL=C < /dev/urandom tr -dC 0-9a-f 2> /dev/null | head -c 8)
          unique_id=${{ github.repository }}/${{ github.run_id }}/$random32
          echo "id=$unique_id" | tee -a $GITHUB_OUTPUT

          # Find a runner that is online, not busy, and not already reserved for
          # any job (label prefix “reserved-for:”).
          runner_id=$(mktemp)
          if ! < $runners > $runner_id jq -e '
            .runners
            | map(select(.status == "online" and .busy == false))
            | map(select([.labels[].name] | map(startswith("reserved-for:")) | index(true) | not))
            | first | .id'; then
            echo "label=$github_hosted_runner_label" | tee -a $GITHUB_OUTPUT
            exit 0
          fi

          # Reserve that runner by adding a label containing the unique id.
          # Job concurrency ensures that runners never get assigned twice.
          gh api "$self_hosted_runner_scope/$(cat $runner_id)/labels" \
            --method POST -f "labels[]=reserved-for:$unique_id"
          echo "label=$self_hosted_runner_label" | tee -a $GITHUB_OUTPUT

  runner-timeout:
    name: Runner timeout
    runs-on: ubuntu-latest
    needs:
      - runner-select
    steps:
      - name: Wait a bit
        run: sleep 10

      - name: Cancel if workload job is still queued
        run: |
          run_url=/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}
          export GH_TOKEN=${{ secrets.GITHUB_TOKEN }}

          if [ "$(gh api "$run_url/jobs" \
            | jq -er --arg id '${{ needs.runner-select.outputs.unique-id }}' \
              '.jobs[] | select(.name | contains("[" + $id + "]")) | .status'
          )" = queued ]; then
            echo "Timeout waiting for runner assignment! Cancelling workflow run"
            gh api "$run_url/cancel" --method POST
          fi

  build:
    name: Windows Build [${{ needs.runner-select.outputs.unique-id }}]
    needs:
      - runner-select
    runs-on: ${{ needs.runner-select.outputs.runner-label }}
    steps:
      - run: echo ok
